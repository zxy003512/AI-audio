<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>语音转文本与AI修正工具</title>
    <style>
        /* Google Font (Optional) */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap');

        :root {
            --primary-color: #007bff; /* 主题蓝 */
            --primary-light: #e6f2ff;
            --primary-dark: #0056b3;
            --secondary-color: #6c757d; /* 次要灰 */
            --success-color: #28a745; /* 成功绿 */
            --success-light: #eaf7ec;
            --error-color: #dc3545; /* 错误红 */
            --error-light: #fdecea;
            --warning-color: #ffc107; /* 警告黄 */
            --warning-light: #fff8e1;
            --recording-color: #e63946; /* 录音红 */
            --background-color: #f8f9fa; /* 页面背景 */
            --card-background: #ffffff; /* 卡片背景 */
            --text-color: #343a40; /* 主要文字颜色 */
            --text-muted: #6c757d; /* 次要文字颜色 */
            --border-color: #dee2e6; /* 边框颜色 */
            --font-family: 'Noto Sans SC', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --border-radius: 8px;
            --box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            --transition-speed: 0.3s;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align top for longer content */
            min-height: 100vh;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }

        .container {
            background-color: var(--card-background);
            padding: 30px 40px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            text-align: center;
            max-width: 900px; /* Increased max-width for side-by-side */
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 25px;
            transition: all var(--transition-speed) ease;
        }

        h1 {
            color: var(--primary-dark);
            margin-top: 0;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .description {
            color: var(--text-muted);
            font-size: 0.95em;
            margin-bottom: 15px;
        }

        #recordButton {
            padding: 12px 25px;
            font-size: 1.1em;
            font-weight: 500;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            background-color: var(--primary-color);
            color: white;
            transition: background-color var(--transition-speed) ease, transform 0.1s ease, box-shadow 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 0 auto; /* Center button */
            min-width: 200px; /* Ensure minimum width */
            box-shadow: 0 2px 5px rgba(0, 123, 255, 0.3);
        }
         #recordButton .icon {
             width: 20px;
             height: 20px;
             fill: currentColor; /* Icon color matches text */
         }


        #recordButton:hover:not(:disabled) {
            background-color: var(--primary-dark);
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.4);
        }

        #recordButton:active:not(:disabled) {
            transform: scale(0.98);
             box-shadow: 0 1px 3px rgba(0, 123, 255, 0.3);
        }

        #recordButton:disabled {
             background-color: var(--secondary-color);
             opacity: 0.7;
             cursor: not-allowed;
             box-shadow: none;
         }

        #recordButton.recording {
            background-color: var(--recording-color);
            animation: pulse 1.5s infinite ease-in-out;
             box-shadow: 0 2px 5px rgba(230, 57, 70, 0.4);
        }
        #recordButton.recording:hover:not(:disabled) {
            background-color: #c81d25; /* Darker red on hover */
            box-shadow: 0 4px 8px rgba(230, 57, 70, 0.5);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(230, 57, 70, 0.7); }
            70% { box-shadow: 0 0 0 12px rgba(230, 57, 70, 0); }
            100% { box-shadow: 0 0 0 0 rgba(230, 57, 70, 0); }
        }


        #recordButton.processing {
             background-color: var(--warning-color);
             cursor: not-allowed;
             color: #333;
             box-shadow: 0 2px 5px rgba(255, 193, 7, 0.4);
         }
         #recordButton.processing .spinner {
             display: inline-block;
         }
         #recordButton.processing .icon { /* Hide main icon when processing */
             display: none;
         }


        #statusContainer {
            margin-top: 10px;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            font-weight: 500;
            min-height: 24px; /* Prevent layout shift */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
            background-color: var(--background-color); /* Default background */
            color: var(--text-muted);
         }
         #statusContainer .icon {
             width: 18px;
             height: 18px;
             fill: currentColor;
             display: none; /* Hide icons by default, show based on class */
         }
         #statusContainer.idle {
             background-color: var(--background-color);
             color: var(--text-muted);
         }
         #statusContainer.info,
         #statusContainer.permission {
             background-color: var(--primary-light);
             color: var(--primary-dark);
         }
         #statusContainer.recording {
             background-color: #ffebee; /* Light red */
             color: var(--recording-color);
             font-weight: bold;
         }
         #statusContainer.processing {
             background-color: var(--warning-light);
             color: #b98900;
         }
          #statusContainer.success {
              background-color: var(--success-light);
              color: var(--success-color);
          }
          #statusContainer.error {
              background-color: var(--error-light);
              color: var(--error-color);
          }

         /* Show icons based on status class */
         #statusContainer.success .icon-success,
         #statusContainer.error .icon-error,
         #statusContainer.processing .spinner {
             display: inline-block;
         }

        /* Wrapper for transcript and correction areas */
        .results-wrapper {
            display: flex;
            gap: 20px; /* Space between the two boxes */
            width: 100%;
            margin-top: 15px;
        }

        /* Styling for individual transcript/correction containers */
        #transcriptContainer,
        #correctionContainer {
            flex: 1; /* Each takes up half the space */
            min-width: 0; /* Prevent flex items from overflowing */
            text-align: left;
            position: relative; /* For positioning the copy button */
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #transcriptLabel,
        #correctionLabel {
            display: block;
            /* margin-bottom: 8px; */ /* Gap handled by flex container */
            font-weight: 500;
            color: var(--text-color);
        }

        #transcript,
        #correctedTranscript {
            width: 100%;
            min-height: 150px; /* Adjusted height */
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: #f1f3f5; /* Slightly different background */
            font-size: 1em;
            line-height: 1.6;
            box-sizing: border-box;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 350px;
            color: var(--text-color);
            transition: border-color var(--transition-speed) ease;
            flex-grow: 1; /* Allow text area to grow */
        }
        #correctedTranscript {
            background-color: #e9ecef; /* Slightly different for visual distinction */
        }

        #transcript:focus,
        #correctedTranscript:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px var(--primary-light);
        }

        /* Shared copy button styles */
        .copy-button {
            padding: 8px 15px;
            font-size: 0.9em;
            font-weight: 500;
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            background-color: var(--card-background);
            color: var(--secondary-color);
            transition: all var(--transition-speed) ease;
            display: flex;
            align-items: center;
            gap: 6px;
            position: absolute;
            top: -40px; /* Position above the label */
            right: 0;
            z-index: 10;
         }
         .copy-button .icon {
            width: 16px;
            height: 16px;
            fill: currentColor;
         }
        .copy-button:hover:not(:disabled) {
            background-color: var(--secondary-color);
            color: white;
            border-color: var(--secondary-color);
        }
        .copy-button:active:not(:disabled) {
            transform: scale(0.97);
        }
        .copy-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .copy-button.copied {
            background-color: var(--success-color);
            border-color: var(--success-color);
            color: white;
        }
         .copy-button.copied .icon-copy {
            display: none;
         }
         .copy-button.copied .icon-check {
            display: inline-block !important; /* Force show check icon */
         }
         /* Specific IDs for JS targeting */
         #copyButton {}
         #copyCorrectionButton {}


        .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: var(--text-color); /* Match button text color */
            animation: spin 1s linear infinite;
            display: none; /* Hide by default */
        }
        #recordButton.processing .spinner {
             border-top-color: #333; /* Spinner color for processing button */
         }
         #statusContainer .spinner {
             width: 16px;
             height: 16px;
             border: 2px solid rgba(0, 0, 0, 0.1);
              border-top-color: currentColor; /* Spinner color matches status text color */
              animation: spin 1s linear infinite;
              display: none; /* Hide by default */
          }


        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive Adjustments */
        @media (max-width: 700px) {
            .container {
                padding: 20px;
                gap: 20px;
            }
             h1 {
                 font-size: 1.6em;
             }
             #recordButton {
                 font-size: 1em;
                 padding: 10px 20px;
                 min-width: 180px;
             }
            .results-wrapper {
                flex-direction: column; /* Stack vertically */
                gap: 15px;
            }
            #transcriptContainer,
            #correctionContainer {
                flex: none; /* Reset flex property */
                width: 100%;
            }
            #transcript,
            #correctedTranscript {
                min-height: 100px;
                max-height: 200px; /* Reduced max height */
            }
            .copy-button {
                 padding: 6px 12px;
                 font-size: 0.85em;
                 top: -35px; /* Adjust for smaller screens */
             }
         }
         @media (max-width: 400px) {
              h1 {
                  font-size: 1.4em;
              }
              #recordButton {
                  width: 100%; /* Full width on very small screens */
              }
             /* Stack copy buttons below text areas on very small screens */
             #transcriptContainer,
             #correctionContainer {
                 position: static; /* Reset relative positioning */
             }
             .copy-button {
                 position: static; /* Stack copy button below */
                 margin-top: 10px;
                 align-self: flex-end; /* Align button to the right */
             }
         }

         /* SVG Icons - Define them once */
         .icon-mic { display: inline-block; }
         .icon-stop { display: none; } /* Initially hidden */
         .icon-copy { display: inline-block; }
         .icon-check { display: none; } /* Initially hidden */
         .icon-success { display: none; } /* Initially hidden */
         .icon-error { display: none; } /* Initially hidden */

    </style>
</head>
<body>
    <svg width="0" height="0" style="position:absolute">
      <defs>
        <symbol id="icon-mic" viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.91-3c-.49 0-.9.36-.98.85C16.58 14.86 14.49 16 12 16s-4.58-1.14-4.93-4.15c-.08-.49-.49-.85-.98-.85-.61 0-1.09.54-1 1.14.18 3.02 2.5 5.36 5.43 5.77V21h-2c-.55 0-1 .45-1 1s.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1h-2v-2.09c2.93-.41 5.25-2.75 5.43-5.77.09-.6-.39-1.14-1-1.14z"/></symbol>
        <symbol id="icon-stop" viewBox="0 0 24 24"><path d="M6 6h12v12H6z"/></symbol>
        <symbol id="icon-copy" viewBox="0 0 24 24"><path d="M16 1H4C2.9 1 2 1.9 2 3v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></symbol>
        <symbol id="icon-check" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></symbol>
        <symbol id="icon-success" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 16.17l7.59-7.59L19 10l-9 9z"/></symbol>
        <symbol id="icon-error" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></symbol>
      </defs>
    </svg>

    <div class="container">
        <h1>语音转文本 & AI 修正</h1>
        <p class="description">点击按钮开始录音，再次点击停止。转换后，AI 将自动检查并修正文本。</p>

        <button id="recordButton">
            <svg class="icon icon-mic" aria-hidden="true"><use xlink:href="#icon-mic"></use></svg>
            <svg class="icon icon-stop" aria-hidden="true"><use xlink:href="#icon-stop"></use></svg>
            <span id="buttonText">开始录音</span>
            <span class="spinner"></span>
        </button>

        <div id="statusContainer" class="idle">
             <svg class="icon icon-success" aria-hidden="true"><use xlink:href="#icon-success"></use></svg>
             <svg class="icon icon-error" aria-hidden="true"><use xlink:href="#icon-error"></use></svg>
             <span class="spinner"></span>
             <span id="statusText">状态: 空闲</span>
        </div>

        <div class="results-wrapper">
            <div id="transcriptContainer">
                <label id="transcriptLabel" for="transcript">原始转换结果:</label>
                <div id="transcript" role="log" aria-live="polite" contenteditable="false" aria-label="原始转录文本区域"></div>
                <button id="copyButton" class="copy-button" disabled title="复制原始文本">
                    <svg class="icon icon-copy" aria-hidden="true"><use xlink:href="#icon-copy"></use></svg>
                    <svg class="icon icon-check" aria-hidden="true"><use xlink:href="#icon-check"></use></svg>
                    <span class="copy-button-text">复制</span>
                </button>
            </div>

            <div id="correctionContainer">
                <label id="correctionLabel" for="correctedTranscript">AI 修正结果:</label>
                <div id="correctedTranscript" role="log" aria-live="polite" contenteditable="false" aria-label="AI修正后的文本区域"></div>
                <button id="copyCorrectionButton" class="copy-button" disabled title="复制修正文本">
                    <svg class="icon icon-copy" aria-hidden="true"><use xlink:href="#icon-copy"></use></svg>
                    <svg class="icon icon-check" aria-hidden="true"><use xlink:href="#icon-check"></use></svg>
                    <span class="copy-button-text">复制</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const API_KEY = "sk-e2a7YHPCZF3yPxpdu9zguWbNlawBJwAQ3a0jav4U6B5LlECK"; // 请替换为你的 API Key (客户端暴露不安全!)
        const API_URL = "https://api.zetatechs.com/v1/chat/completions"; // 你的代理 URL + 端点
        const MODEL_NAME = "gemini-2.5-flash-preview-04-17-nothinking";
        const TRANSCRIPTION_PROMPT = "Transcribe the following audio. Only provide the transcribed text, nothing else.请你使用简体中文"; // AI 转录提示 (英文)
        // --- NEW: Correction Prompt ---
        const CORRECTION_PROMPT = "Please proofread and correct the following speech-to-text content for fluency, typos, extra spaces, punctuation errors, and other mistakes.

Output ONLY the corrected text without any explanations or other content.

This is because the content was generated after the user used speech-to-text, so you need to correct any minor deviations or errors."; // AI 修正提示 (英文)
        const AUDIO_MIME_TYPE = 'audio/ogg;codecs=opus'; // 常用格式
        const MAX_RETRIES = 2; // API 失败时最大重试次数

        // --- DOM Elements ---
        const recordButton = document.getElementById('recordButton');
        const buttonText = document.getElementById('buttonText');
        const statusContainer = document.getElementById('statusContainer');
        const statusText = document.getElementById('statusText');
        const transcriptDiv = document.getElementById('transcript');
        const copyButton = document.getElementById('copyButton');
        const copyButtonText = copyButton.querySelector('.copy-button-text');
        const recordButtonSpinner = recordButton.querySelector('.spinner');
        const statusSpinner = statusContainer.querySelector('.spinner');
        // --- NEW: Correction Elements ---
        const correctionContainer = document.getElementById('correctionContainer');
        const correctedTranscriptDiv = document.getElementById('correctedTranscript');
        const copyCorrectionButton = document.getElementById('copyCorrectionButton');
        const copyCorrectionButtonText = copyCorrectionButton.querySelector('.copy-button-text');


        // Icon Elements inside recordButton
        const recordButtonMicIcon = recordButton.querySelector('.icon-mic');
        const recordButtonStopIcon = recordButton.querySelector('.icon-stop');
        // Icon Elements inside copyButton
        const copyButtonCopyIcon = copyButton.querySelector('.icon-copy');
        const copyButtonCheckIcon = copyButton.querySelector('.icon-check');
        // --- NEW: Icon Elements inside correction copyButton ---
        const copyCorrectionButtonCopyIcon = copyCorrectionButton.querySelector('.icon-copy');
        const copyCorrectionButtonCheckIcon = copyCorrectionButton.querySelector('.icon-check');


        // --- State Variables ---
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let stream;
        let permissionGranted = false;
        let retryCount = 0;
        let correctionRetryCount = 0; // Separate retry count for correction

        // --- Functions ---

        // Manage Button Icon Visibility
        function setRecordButtonIcon(state) { // 'mic', 'stop'
             recordButtonMicIcon.style.display = (state === 'mic') ? 'inline-block' : 'none';
             recordButtonStopIcon.style.display = (state === 'stop') ? 'inline-block' : 'none';
             recordButtonSpinner.style.display = 'none'; // Ensure spinner is hidden initially
         }

        // Request Microphone Permission on Load
        async function requestMicrophonePermission() {
            updateStatus("正在请求麦克风权限...", "permission");
            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                permissionGranted = true;
                updateStatus("麦克风访问已授权，准备录音。", "info");
                // Release the initial stream to avoid keeping the mic active
                stream.getTracks().forEach(track => track.stop());
                stream = null;
                recordButton.disabled = false; // Enable button now
                setRecordButtonIcon('mic'); // Set initial icon
            } catch (err) {
                console.error("访问麦克风失败:", err);
                updateStatus("麦克风访问被拒绝。请在浏览器设置中允许访问。", "error");
                permissionGranted = false;
                recordButton.disabled = true;
                buttonText.textContent = "无权限";
                setRecordButtonIcon('mic'); // Keep mic icon, but disabled
            }
        }

        // Update Status Display
        function updateStatus(message, type = "idle") { // type: idle, info, permission, recording, processing, success, error
             statusText.textContent = `状态: ${message}`;
             // Reset class list completely before adding new type
             statusContainer.className = 'status-container';
             statusContainer.classList.add(type);

             // Show/hide spinner in status area only when processing or correction is processing
             statusSpinner.style.display = (type === 'processing') ? 'inline-block' : 'none';
         }

        // Start Recording
        async function startRecording() {
             if (!permissionGranted) {
                 updateStatus("无法录音，缺少麦克风权限。", "error");
                 await requestMicrophonePermission(); // Try again
                 if (!permissionGranted) return;
             }

             if (isRecording) return;

             updateStatus("正在初始化...", "info");
             audioChunks = [];
             transcriptDiv.textContent = ""; // Clear previous transcript
             correctedTranscriptDiv.textContent = ""; // Clear correction area
             copyButton.disabled = true; // Disable copy button
             copyCorrectionButton.disabled = true; // Disable correction copy button
             resetCopyButtonState(); // Reset copy button visual state
             resetCorrectionCopyButtonState(); // Reset correction copy button state

             try {
                 stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                 let options = {};
                 if (MediaRecorder.isTypeSupported(AUDIO_MIME_TYPE)) {
                     options.mimeType = AUDIO_MIME_TYPE;
                 } // else use browser default

                 mediaRecorder = new MediaRecorder(stream, options);

                 mediaRecorder.ondataavailable = event => {
                     if (event.data.size > 0) {
                         audioChunks.push(event.data);
                     }
                 };

                 mediaRecorder.onstop = () => {
                     isRecording = false;
                     recordButton.classList.remove('recording');
                     recordButton.classList.add('processing');
                     buttonText.textContent = "处理中...";
                     setRecordButtonIcon(null); // Hide icons
                     recordButtonSpinner.style.display = 'inline-block'; // Show button spinner
                     recordButton.disabled = true;
                     updateStatus("正在处理音频...", "processing");

                     if (stream) {
                         stream.getTracks().forEach(track => track.stop());
                         stream = null;
                     }

                     const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/ogg' }); // Fallback mime type
                     retryCount = 0;
                     sendAudioToApi(audioBlob);
                 };

                 mediaRecorder.onerror = (event) => {
                     console.error("MediaRecorder 错误:", event.error);
                     updateStatus(`录音出错: ${event.error.name || '未知错误'}`, "error");
                     stopRecordingCleanup(); // Clean up state forcefully
                 };

                 mediaRecorder.start();
                 isRecording = true;
                 recordButton.classList.add('recording');
                 buttonText.textContent = "停止录音";
                 setRecordButtonIcon('stop'); // Show stop icon
                 updateStatus("正在录音...", "recording");

             } catch (err) {
                 console.error("开始录音失败:", err);
                 updateStatus(`无法开始录音: ${err.message}`, "error");
                 stopRecordingCleanup(); // Ensure state is clean
             }
         }

         // Force cleanup if recording fails to start or has an error
         function stopRecordingCleanup() {
             isRecording = false;
             if (stream) {
                 stream.getTracks().forEach(track => track.stop());
                 stream = null;
             }
             if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                 try { mediaRecorder.stop(); } catch(e) { /* ignore */ } // Try to stop if possible
             }
             resetButtonState(); // Reset button visuals
             // Also clear results and disable copy buttons
             transcriptDiv.textContent = "";
             correctedTranscriptDiv.textContent = "";
             copyButton.disabled = true;
             copyCorrectionButton.disabled = true;
             resetCopyButtonState();
             resetCorrectionCopyButtonState();
         }


        // Stop Recording (normal flow)
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                try {
                    mediaRecorder.stop(); // Triggers 'onstop'
                } catch (error) {
                    console.error("停止 MediaRecorder 出错:", error);
                    updateStatus("停止录音时出错。", "error");
                    stopRecordingCleanup(); // Force cleanup on error
                }
            }
        }

        // Convert Blob to Base64
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const base64String = reader.result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = (error) => reject(new Error("无法读取音频文件: " + error));
                reader.readAsDataURL(blob);
            });
        }

        // Send Audio to API for Transcription
        async function sendAudioToApi(audioBlob) {
            updateStatus(`正在发送到 AI 转录 (尝试 ${retryCount + 1}/${MAX_RETRIES + 1})...`, "processing");
            const recordedMimeType = mediaRecorder?.mimeType || AUDIO_MIME_TYPE;

            try {
                const base64Audio = await blobToBase64(audioBlob);

                const payload = {
                    model: MODEL_NAME,
                    messages: [ {
                        role: "user",
                        content: [
                            { type: "text", text: TRANSCRIPTION_PROMPT },
                            {
                                type: "image_url", // Adapting for multimodal endpoint
                                image_url: { url: `data:${recordedMimeType};base64,${base64Audio}` }
                            }
                        ]
                    } ],
                    max_tokens: 1500 // Increased slightly
                };

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_KEY}`
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorBody = `HTTP 状态 ${response.status}`;
                    try { errorBody = await response.text(); } catch (e) { /* ignore */ }
                    throw new Error(`API 转录请求失败: ${errorBody.substring(0, 100)}`); // Limit error msg length
                }

                const data = await response.json();
                resetButtonState(); // Reset button now transcription part is done or failed finally

                let transcript = "";
                 // Standard OpenAI-like response structure
                 if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                     transcript = data.choices[0].message.content.trim();
                 // Potential Gemini structure passthrough
                 } else if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0 && data.candidates[0].content.parts[0].text) {
                    transcript = data.candidates[0].content.parts[0].text.trim();
                 } else {
                     console.warn("未知的 API 转录响应结构:", data);
                     transcript = "[无法解析转录响应]"; // Provide feedback
                     updateStatus("收到无法解析的转录响应。", "error");
                     copyButton.disabled = true;
                     correctedTranscriptDiv.textContent = "[原文无效，无法修正]"; // Add note in correction box
                     copyCorrectionButton.disabled = true;
                 }


                if (transcript && transcript !== "[无法解析转录响应]") {
                    transcriptDiv.textContent = transcript;
                    updateStatus("转录完成。正在调用 AI 检查...", "processing"); // Update status for next step
                    copyButton.disabled = false;
                    // --- Call AI for Correction ---
                    correctionRetryCount = 0; // Reset correction retry count
                    callAiForCorrection(transcript); // Automatically call correction
                    // -----------------------------
                } else if (transcript !== "[无法解析转录响应]") { // Handle empty transcript case
                    transcriptDiv.textContent = "[未识别到语音或返回为空]";
                    updateStatus("未返回有效文本。", "info"); // Use 'info' or 'warning'
                    copyButton.disabled = true;
                    correctedTranscriptDiv.textContent = "[原文无效，无法修正]";
                    copyCorrectionButton.disabled = true;
                } // else case (解析错误) handled above


            } catch (error) {
                console.error("发送音频到 API 时出错:", error);
                if (retryCount < MAX_RETRIES) {
                    retryCount++;
                    updateStatus(`转录 API 错误: ${error.message}. 2秒后重试... (尝试 ${retryCount + 1}/${MAX_RETRIES + 1})`, "error");
                    setTimeout(() => sendAudioToApi(audioBlob), 2000);
                } else {
                    updateStatus(`转录 API 错误 (${MAX_RETRIES + 1}次尝试失败): ${error.message}`, "error");
                    transcriptDiv.textContent = "[转换失败]";
                    correctedTranscriptDiv.textContent = "[原文转换失败，无法修正]";
                    resetButtonState(); // Ensure button is usable after final failure
                    copyButton.disabled = true;
                    copyCorrectionButton.disabled = true;
                }
            }
        }

        // --- NEW: Call AI for Correction ---
        async function callAiForCorrection(originalText) {
             updateStatus(`AI 正在检查文本... (尝试 ${correctionRetryCount + 1}/${MAX_RETRIES + 1})`, "processing");
             correctedTranscriptDiv.textContent = "AI 检查中..."; // Placeholder
             copyCorrectionButton.disabled = true;
             resetCorrectionCopyButtonState();

             try {
                const payload = {
                    model: MODEL_NAME,
                    messages: [ {
                        role: "user",
                        content: [
                            { type: "text", text: CORRECTION_PROMPT },
                            { type: "text", text: "\n---\n" + originalText + "\n---" } // Send original text clearly marked
                        ]
                    } ],
                    max_tokens: 1600 // Allow slightly more tokens for correction
                 };

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_KEY}`
                    },
                    body: JSON.stringify(payload)
                });

                 if (!response.ok) {
                    let errorBody = `HTTP 状态 ${response.status}`;
                    try { errorBody = await response.text(); } catch (e) { /* ignore */ }
                    throw new Error(`API 修正请求失败: ${errorBody.substring(0, 100)}`);
                }

                 const data = await response.json();

                let correctedText = "";
                 // Standard OpenAI-like response structure
                 if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                     correctedText = data.choices[0].message.content.trim();
                 // Potential Gemini structure passthrough
                 } else if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0 && data.candidates[0].content.parts[0].text) {
                    correctedText = data.candidates[0].content.parts[0].text.trim();
                 } else {
                     console.warn("未知的 API 修正响应结构:", data);
                     correctedText = "[无法解析修正响应]";
                     updateStatus("收到无法解析的修正响应。", "error");
                     copyCorrectionButton.disabled = true;
                 }

                 if (correctedText && correctedText !== "[无法解析修正响应]") {
                    correctedTranscriptDiv.textContent = correctedText;
                    updateStatus("AI 修正完成。", "success"); // Final success status
                    copyCorrectionButton.disabled = false;
                 } else if (correctedText !== "[无法解析修正响应]") { // Handle empty correction
                     correctedTranscriptDiv.textContent = "[AI 未返回有效修正文本]";
                     updateStatus("AI 修正未返回有效文本。", "info");
                     copyCorrectionButton.disabled = true;
                 }
                 // else case (解析错误) handled above

             } catch (error) {
                 console.error("调用 AI 修正时出错:", error);
                 if (correctionRetryCount < MAX_RETRIES) {
                     correctionRetryCount++;
                     updateStatus(`修正 API 错误: ${error.message}. 2秒后重试... (尝试 ${correctionRetryCount + 1}/${MAX_RETRIES + 1})`, "error");
                     setTimeout(() => callAiForCorrection(originalText), 2000);
                 } else {
                     updateStatus(`修正 API 错误 (${MAX_RETRIES + 1}次尝试失败): ${error.message}`, "error");
                     correctedTranscriptDiv.textContent = "[AI 修正失败]";
                     copyCorrectionButton.disabled = true;
                     // Keep original transcript accessible if it succeeded
                 }
             }
         }


        // Reset Button and Spinner State
        function resetButtonState() {
             recordButton.classList.remove('processing', 'recording');
             recordButton.disabled = false;
             buttonText.textContent = "开始录音";
             setRecordButtonIcon('mic'); // Reset icon to mic
             recordButtonSpinner.style.display = 'none';
         }

        function resetCopyButtonState() {
             copyButton.classList.remove('copied');
             copyButtonText.textContent = "复制";
             copyButtonCopyIcon.style.display = 'inline-block';
             copyButtonCheckIcon.style.display = 'none';
         }
        // --- NEW: Reset Correction Copy Button ---
         function resetCorrectionCopyButtonState() {
             copyCorrectionButton.classList.remove('copied');
             copyCorrectionButtonText.textContent = "复制";
             copyCorrectionButtonCopyIcon.style.display = 'inline-block';
             copyCorrectionButtonCheckIcon.style.display = 'none';
         }


        // Copy Original Transcript to Clipboard
        function copyTranscript() {
            const textToCopy = transcriptDiv.textContent;
            if (!textToCopy || textToCopy.startsWith("[")) { // Check for empty or error messages
                updateStatus("原始文本没有可复制的内容。", "info");
                return;
            }

            navigator.clipboard.writeText(textToCopy).then(() => {
                // Don't overwrite main status if correction is happening/done
                // updateStatus("原始文本已复制！", "success");
                copyButton.classList.add('copied');
                copyButtonText.textContent = "已复制";
                copyButtonCopyIcon.style.display = 'none';
                copyButtonCheckIcon.style.display = 'inline-block';

                // Revert button state after a short delay
                setTimeout(() => {
                    resetCopyButtonState();
                }, 2000);
            }).catch(err => {
                console.error('复制原始文本失败: ', err);
                updateStatus("复制原始文本失败，请手动复制。", "error");
                 resetCopyButtonState();
            });
        }

        // --- NEW: Copy Corrected Transcript ---
        function copyCorrectedTranscript() {
             const textToCopy = correctedTranscriptDiv.textContent;
             if (!textToCopy || textToCopy.startsWith("[")) { // Check for empty or error messages
                 updateStatus("修正文本没有可复制的内容。", "info");
                 return;
             }

             navigator.clipboard.writeText(textToCopy).then(() => {
                 // updateStatus("修正文本已复制！", "success"); // Maybe update status briefly?
                 copyCorrectionButton.classList.add('copied');
                 copyCorrectionButtonText.textContent = "已复制";
                 copyCorrectionButtonCopyIcon.style.display = 'none';
                 copyCorrectionButtonCheckIcon.style.display = 'inline-block';

                 // Revert button state after a short delay
                 setTimeout(() => {
                     resetCorrectionCopyButtonState();
                 }, 2000);
             }).catch(err => {
                 console.error('复制修正文本失败: ', err);
                 updateStatus("复制修正文本失败，请手动复制。", "error");
                  resetCorrectionCopyButtonState();
             });
         }

        // --- Event Listeners ---
        recordButton.addEventListener('click', () => {
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        });

        copyButton.addEventListener('click', copyTranscript);
        // --- NEW: Listener for correction copy button ---
        copyCorrectionButton.addEventListener('click', copyCorrectedTranscript);

        // --- Initialization ---
        window.onload = () => {
             recordButton.disabled = true; // Disable until permission checked
             buttonText.textContent = "检查权限...";
             setRecordButtonIcon('mic'); // Show mic icon initially
             requestMicrophonePermission();
             // Initialize correction area
             correctedTranscriptDiv.textContent = "";
             copyCorrectionButton.disabled = true;
          };

    </script>

</body>
</html>
